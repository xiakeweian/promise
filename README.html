<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="promise">promise</h1>
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF-promise">什么是 promise?</h2>
<h3 id="1%E7%AE%80%E8%BF%B0">1.简述</h3>
<p>ECMAscript 6 原生提供了 Promise 对象，Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。
promise 是一个自执行函数，我们只要调用它就开始执行了，只是 new 了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。
promise 相当于异步操作结果的占位符，让函数返回一个 Promise 对象，解决异步回调地狱的问题。</p>
<h3 id="2-promise-%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%A6%82%E4%B8%8B%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9">2. promise 对象有如下三个特点：</h3>
<ol>
<li>pending 进行中 初始状态，不是成功或失败状态</li>
<li>fulfilled 意味着操作成功完成</li>
<li>rejected 失败完成 意味着操作失败
promise 状态只能从 pending 状态进入到 fulfilled 和 rejected 其中的一个,即：<br>
从 pending ➡️ fulfilled<br>
从 pending ➡️ rejected<br>
promise 状态一经改变不能再更改，因此 resolve，reject 只有第一次执行有效</li>
</ol>
<p>then 和 catch 都会返回一个新的 promise，并且返回值不能是 promise 本身，否则会造成死循环，返回任意一个非 promise 的值都将包裹成 promise 对象，相当于 return Promise.resolve(data)
then 方法可传递两个参数，一个为 fulfilled 状态时调用的函数 resloved，一个为 rejected 时调用的函数 rejected</p>
<h3 id="3%E6%B5%81%E7%A8%8B">3.流程</h3>
<p><img src="./images/1.png" alt=""></p>
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-promise">为什么使用 promise？</h2>
<p>之前处理异步是通过纯粹的回调函数的形式进行处理，很容易进入到回调地狱中，问题可以解决，但是难以读懂，维护困难，稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护
回调地狱就是回调函数嵌套调用，外部回调函数异步执行的结果作为内部回调函数执行的条件
promise 可解决回调地狱
在 promise 出现之前，比如在请求三个接口 api1,api2,api3 在请求 api3 接口的结果之前需要 api1,api2 依次请求之后，api1,api2 的返回结果作为 api3 请求接口的参数，这样很容易出现多层嵌套的问题，比如：</p>
<pre class="hljs"><code><div>$ajax({
  <span class="hljs-attr">url</span>: <span class="hljs-string">"http://www.api1"</span>,
  <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    $ajax({
      <span class="hljs-attr">url</span>: <span class="hljs-string">`http://www.api2`</span>,
      <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
        $ajax({
          <span class="hljs-attr">url</span>: <span class="hljs-string">`http://www.api3`</span>,
          <span class="hljs-attr">success</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(res);
          },
        });
      },
    });
  },
});
</div></code></pre>
<pre class="hljs"><code><div>doFirstThing(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
  doSecondThing(
    result,
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result2</span>) </span>{
      doThirdThing(
        result2,
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">lastResult</span>) </span>{
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"get last result"</span>);
        },
        failureCallback
      );
    },
    failureCallback
  );
}, failureCallback);
</div></code></pre>
<p>以上代码是水平向右发展的，而且异常需要每个回调函数里面单独处理，这样不便于阅读而且很难维护
使用 promise 链式调用解决回调地狱问题，而且不用对每个回调进行异常处理，任何一个出了问题，最终都会穿透都会进入到 catch 方法里面（<code>异常穿透</code>），用 promise 异常处理方便，阅读方便，维护方便，同步编码方式。</p>
<p>终极解决方案：async await</p>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">something1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> something2();
    <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> something3(result1);
    <span class="hljs-keyword">const</span> result3 = <span class="hljs-keyword">await</span> something4(result2);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"get final result"</span>, result3);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(error);
  }
}
</div></code></pre>
<h2 id="how-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-promise">how 怎么使用 promise？</h2>
<p>promise 方法会结合原理讲解：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">then()</td>
<td style="text-align:left">返回一个 promise，会等里面的 then()执行完，再执行外面的</td>
</tr>
<tr>
<td style="text-align:left">catch()</td>
<td style="text-align:left">返回一个 promise，捕获抛出的错误，处理拒绝的情况。它的行为与调用 Promise.prototype.then(undefined, onRejected) 相同</td>
</tr>
<tr>
<td style="text-align:left">all()</td>
<td style="text-align:left">返回一个 promise 实例，批量执行,全部执行完才算完成；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因是第一个失败 promise 的结果。在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。</td>
</tr>
<tr>
<td style="text-align:left">race()</td>
<td style="text-align:left">返回一个 promise,类似于 Promise.all() ，区别在于它有任意一个完成就算完成，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</td>
</tr>
<tr>
<td style="text-align:left">allSettled()</td>
<td style="text-align:left">返回一个 promise，该 promise 都已经 fulfilled 或 rejected 后的 promise，并带有一个对象数组，并且每个对象都描述每个 promise 的结果。</td>
</tr>
<tr>
<td style="text-align:left">finally()</td>
<td style="text-align:left">不管 promise 最后的状态是 resolve 还是 reject，在执行完 then 或 catch 指定的回调函数以后，都会执行 finally 方法指定的回调函数。</td>
</tr>
<tr>
<td style="text-align:left">any()</td>
<td style="text-align:left">接收一个 Promise 可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise</td>
</tr>
<tr>
<td style="text-align:left">自定义 resolveDelay()</td>
<td style="text-align:left">返回一个 promise 对象，在指定对事件后才产生结果</td>
</tr>
<tr>
<td style="text-align:left">自定义 rejectDelay()</td>
<td style="text-align:left">返回一个 promise 对象，在指定对事件后才失败</td>
</tr>
</tbody>
</table>
<ol>
<li>then()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  resolve(<span class="hljs-number">1</span>);
})
  .then(
    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onResolved1"</span>, value);
    },
    (reason) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onRejected1"</span>, reason);
    }
  )
  .then(
    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onResolved2"</span>, value);
    },
    (reason) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onRejected2"</span>, reason);
    }
  );
</div></code></pre>
<p>那么，以上代码会有怎样的输出呢？</p>
<p>输出：
onResolved1 1
onResolved2 undefined</p>
<p>原因：new Promise 执行成功，而 promise.then()执行的回调函数由新的 promise 来决定，如果执行成功，将会执行 onResolved 的回调函数，反之如果新的 promise 对象执行失败，将会执行 onRejected 回调函数，所以第一个 then 中将会输出 onResolved1 1,第二个.then()执行什么回调函数由前一个.then 执行的结果决定，如果前一个.then 执行成功，则第二个.then 执行成功的回调函数（onResolved）,反之将会执行失败的回调函数（onRejected）;第一 then 由成功的输出，then 的返回结果是 undefined 所以第二个 then 中输出是 undefined</p>
<ol start="2">
<li>catch()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
  resolve(<span class="hljs-string">"Success"</span>);
});

p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// "Success!"</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-string">"oh, no!"</span>;
})
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
    <span class="hljs-built_in">console</span>.log(e); <span class="hljs-comment">// "oh, no!"</span>
  })
  .then(
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"after a catch the chain is restored"</span>);
    },
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not fired due to the catch"</span>);
    }
  );
</div></code></pre>
<ol start="3">
<li>all()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>); <span class="hljs-comment">//如果是一般值，p1 成功，value 就是这个值</span>
<span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>)); <span class="hljs-comment">//如果是成功的 promise，p2 成功，value 就是这个值</span>
<span class="hljs-keyword">const</span> p3 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">4</span>)); <span class="hljs-comment">//如果是失败的 promise，p3 失败，reason 就是这个值</span>
p1.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"p1"</span>, value));
p2.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"p2"</span>, value));
p3.catch(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"p3"</span>, reason));
<span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    resolve(<span class="hljs-number">5</span>);
    <span class="hljs-comment">// reject(6);</span>
  }, <span class="hljs-number">1000</span>);
})
  .then(
    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onResolved1"</span>, value);
    },
    (reason) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onRejected1"</span>, reason);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        reject(<span class="hljs-number">5</span>);
      });
    }
  )
  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(err, <span class="hljs-string">"pppp"</span>);
  });

<span class="hljs-built_in">Promise</span>.all([p1, p2, p4]).then(
  <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value, <span class="hljs-string">"values"</span>);
  },
  (reason) =&gt; {
    <span class="hljs-built_in">console</span>.log(reason, <span class="hljs-string">"reason"</span>);
  }
);
</div></code></pre>
<ol start="4">
<li>race()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"promise"</span>);
  <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) {
      resolve(<span class="hljs-string">"huangbiao"</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// debugger</span>
      reject(<span class="hljs-string">"error"</span>);
    }
  }, <span class="hljs-number">1000</span>);
})
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"success"</span>);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"catch"</span>);
  })
  .finally(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"finally"</span>);
  });
</div></code></pre>
<ol start="5">
<li>allSettled()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> promise1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>
  setTimeout(reject, <span class="hljs-number">100</span>, <span class="hljs-string">"foo"</span>)
);
<span class="hljs-keyword">const</span> promises = [promise1, promise2];

<span class="hljs-built_in">Promise</span>.allSettled(promises).then(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span>
  results.forEach(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(result.status))
);
</div></code></pre>
<ol start="6">
<li>finally()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"promise"</span>);
  <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) {
      resolve(<span class="hljs-string">"huangbiao"</span>);
    } <span class="hljs-keyword">else</span> {
      reject(<span class="hljs-string">"error"</span>);
    }
  }, <span class="hljs-number">1000</span>);
})
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"success"</span>, value);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"catch"</span>, reason);
  })
  .finally(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"finally"</span>);
  });
</div></code></pre>
<ol start="7">
<li>any()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> pErr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  reject(<span class="hljs-string">"失败"</span>);
});

<span class="hljs-keyword">const</span> pSlow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  setTimeout(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">"最终完成"</span>);
});

<span class="hljs-keyword">const</span> pFast = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  setTimeout(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">"很快完成"</span>);
});

<span class="hljs-built_in">Promise</span>.any([pErr, pSlow, pFast]).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(value);
  <span class="hljs-comment">// pFast fulfils first</span>
});
</div></code></pre>
<ol start="8">
<li>resolveDelay()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> p1 = <span class="hljs-built_in">Promise</span>.resolveDelay(<span class="hljs-number">1</span>, <span class="hljs-number">2000</span>);
s;
p1.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(value);
});
</div></code></pre>
<ol start="9">
<li>rejectDelay()</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> p2 = <span class="hljs-built_in">Promise</span>.rejectDelay(<span class="hljs-number">2</span>, <span class="hljs-number">3000</span>);
p2.then(<span class="hljs-literal">null</span>, (reason) =&gt; {
  <span class="hljs-built_in">console</span>.log(reason);
});
</div></code></pre>
<p>promise.then()返回新的 promise 的结果状态由什么决定？</p>
<ol>
<li>简单表达：由 then()指定的回调函数的执行的结果决定</li>
<li>详细表达：</li>
</ol>
<ul>
<li>如果抛出异常，新 promise 变为 rejected，reason 为抛出的异常</li>
<li>如果返回的是非 promise，新的 promise 变为 resolved，value 为返回的值</li>
<li>如果返回的是另一个 promise，此 promise 的结果就会成为新的 promise 结果</li>
</ul>
<p>promise 支持链式调用</p>
<h2 id="where-%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8-promise">where 在哪里使用 promise?</h2>
<ol>
<li>主要用于异步计算</li>
<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</li>
<li>可以在对象之间传递和操作 promise，帮助我们处理队列</li>
</ol>
<h2 id="how-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-promise">how 怎么实现 promise？</h2>
<p>原理请看 Promise_fun.js</p>
<h2 id="promise-%E4%BC%98%E7%BC%BA%E7%82%B9">promise 优缺点</h2>
<ul>
<li>优点：</li>
</ul>
<ol>
<li>支持链式调用;</li>
<li>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数,解决回调地狱问题;</li>
<li>此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消；</li>
<li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部；</li>
<li>当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ol>
<h2 id="%E6%A3%80%E9%AA%8C-promise">检验 promise</h2>
<p>参考：https://www.jianshu.com/p/1b63a13c2701
https://segmentfault.com/a/1190000020034361
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</p>

</body>
</html>
